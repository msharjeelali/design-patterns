# -*- coding: utf-8 -*-
"""Singleton_Pattern.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-iVWbVP7iSE1hjQi0QmgTjpsYLkpKiEL
"""

# exmaple one

class Consumer:
  # class variable to store single instance
  _instance = None

  def __init__(self):
    self.db_url = "something"

  # method that create a new object in memory
  # called before __int__, when Consumer()
  def __new__(cls):
    if cls._instance is None:
      print("Creating new instance")
      cls._instance = super().__new__(cls)
    return cls._instance

def main():
    s1 = Consumer()
    s2 = Consumer()

    print(s1 is s2)
    print(id(s1))
    print(id(s2))

if __name__ == "__main__":
    main()

# example two

# define a Singleton class that inherit from type
# type is a default master class used to create all classes
class Singleton(type):
    # class level dictionary that store exactly one instance per class
    _instances = {}

    # called when we call a class like a function
    # cls is the class we are instanitaing
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            # in real world it may take some time to create instance
            time.sleep(5)
            cls._instances[cls] = instance
        return cls._instances[cls]


# metaclass tells python how to control instances of Consumer
class Consumer(metaclass=Singleton):
    def log(self):
        print(f"{self}\n")


def create_singleton():
    # anytime we write Consumer(), the creation is handled by Singletom.__call__
    singleton = Consumer()
    singleton.log()

if __name__ == "__main__":
    create_singleton()
    create_singleton()

# multi threading can cause our singleton to not work properly (in some cases)
from threading import Thread
import time

if __name__ == "__main__":
    t1 = Thread(target=create_singleton)
    t2 = Thread(target=create_singleton)
    t1.start()
    t2.start()

# to solve multi threading problem we use lock inside our _call__
from threading import Lock

class Singleton(type):
    _instances = {}
    _lock = Lock()

    def __call__(cls, *args, **kwargs):
        while cls._lock:
          if cls not in cls._instances:
              instance = super().__call__(*args, **kwargs)
              time.sleep(5)
              cls._instances[cls] = instance
        return cls._instances[cls]